# redis从海量的key里面查询出某一固定前缀的key

## 生成海量数据

### 1.Linux Bash下面执行(一定要是Bash)

```
for((i=1;i<=20000000;i++)); do echo "set k$i v$i" >> /tmp/redisTest.txt ;done;
```
生成2千万条redis批量设置kv的语句(key=kn,value=vn)写入到/tmp目录下的redisTest.txt文件中

### 2.用vim去掉行尾的^M符号，使用方式如下：
```
vim /tmp/redisTest.txt
:set fileformat=dos #设置文件的格式，通过这句话去掉每行结尾的^M符号
::wq #保存退出
```

### 3.通过redis提供的管道--pipe形式，去跑redis，传入文件的指令批量灌数据，需要花10分钟左右
```
cat /tmp/redisTest.txt | redis-cli -h [主机ip] -p [端口号] -a [密码] --pipe
```
使用keys pattern
使用keys对上线业务的影响

明确数据规模
keys指令一次性返回所有匹配的key
键的数量过大会使得服务卡顿
当前redis数据库的数据量
```
127.0.0.1:6380> dbsize
(integer) 1901534
```
匹配测试
```
keys k1*
(3.55s)   #用时3.0+s,个人pc性能不同
```
使用scan
语法
```
scan cursor [MATCH pattern] [COUNT count]
```
scan介绍

基于游标的迭代器,需要基于上一次游标延续之前的迭代过程
以0作为游标开始一次新的迭代,直到命令返回游标0完成一次遍历
不保证每次执行都会返回某个给定数量的元素,支持模糊查询
一次返回的数量不可控,只能是大概率符合count参数
示例
```
127.0.0.1:6380> scan 0 match k1* count 10
1) "655360"
2) 1) "k1864385"
   2) "k1392840"
   3) "k1388130"
   4) "k1357007"
   5) "k1743332"
   6) "k1593973"
   7) "k1399047"
127.0.0.1:6380> scan 655360 match k1* count 10
1) "327680"
2) 1) "k1610178"
   2) "k1693505"
   3) "k1032175"
   4) "k1721788"
   5) "k1678140"
   6) "k1359412"
127.0.0.1:6380> scan 327680 match k1* count 10
1) "2031616"
2) 1) "k1798037"
   2) "k1805785"
   3) "k1837836"
   4) "k1138914"
   5) "k1689917"
   6) "k1033258"
```

tips:

游标的大小不是固定的,非递增或递减.

count指定返回数据量不是一定的,只是大体符合

scan命令获取到的key有可能是重复的,可以利用Java的Set进行去重操作

# 小结:

从海量的key里面查询出某一固定前缀的key的时候,
第一,要注意数据量,
第二,在使用keys命令的时候会一次性返回所有的keys会造成卡顿,而使用scan命令的时候要注意去重和获取上一次的游标

# redis

## IO多路复用原理

![image](https://github.com/user-attachments/assets/f63cd8d2-640f-442f-9234-821de9e767ae)


## Redis 主从模式保证高并发和高可用(哨兵模式)

### 读写分离

单机的 Redis 的 QPS 大概就在上万到几万不等，无法承受更高的并发。

读写分离保证高并发(10W+ QPS)：对于缓存来说一般都是支撑高并发读，写请求都是比较少的。采用读写分离的架构(一主多从)，master 负责接收写请求，数据同步到 slave 上提供读服务，如果遇到瓶颈只需要增加 slave 机器就可以水平扩容

### 主从复制机制

## Redis 过期策略

redis内存不足时的处理

* 惰性删除
  * 每隔100ms 通过LRU 抽取部分过期的数据进行释放。
  * 查询数据时，如果已经过期，便释放。

对 key 设置有效期，redis 的删除策略: `定期删除+惰性删除`。

1. 定期删除指的是 redis 默认每 100ms 就随机抽取一些设置了过期事件的 key ，检查是否过期，如果过期就删除。如果 redis 设置了 10 万个 key 都设置了过期时间，每隔几百毫秒就要检查 10 万个 key 那 CPU 负载就很高了，所以 redis 并不会每隔 100ms 就检查所有的 key，而是随机抽取一些 key 来检查。
2. 但这样会导致有些 key 过期了并没有被删除，所以采取了惰性删除。意思是在获取某个 key 的时候发现过期了，如果 key 过期了就删除掉不会返回。

这两个策略结合起来保证过期的 key 一定会被删除。

## Redis 数据的恢复(Redis 的持久化)

### RDB


### AOF


# 小结

* redis内存管理的思想 很多golang/c++本地缓存 均可借鉴。

# 参考链接

- [Redis 知识总结](https://www.toutiao.com/article/7111628577396916768/)

